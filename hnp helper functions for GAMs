
###############################################################################################
######################## "hnp" helper functions for "mgcv" ####################################
###############################################################################################

## The "hnp" package cannot currently be used to assess the adequacy of GAMs fitted in "mgcv".
## Three helper functions, namely dfun(), sfun(), and ffun(), can jointly be employed to allow
## to make this possible, therefore providing an additional adequacy assessment tool for "mgcv".

## The dfun() function extracts the deviance (or other types of) residuals of a given GAM. This
## This first function remains the same at all times.

## The sfun() function perform simulations to determine how the residuals should behave under 
## the distributional assumptions of the fitted GAM. Each distribution family has its own
## sfun() function (see below).

## The ffun() function refits the considered GAM 99 times (default value) to allow to produce a
## single half-normal (diagnostic) plot with a simulated envelope when jointly used with the 
## dfun() and sfun() functions within the original hnp() function of hnp(), as shown below. The
## ffun() function is specific to the GAM being assessed.


## sfun() function for commonly-used distribution families

## Gaussian distribution with identity link




## First, define the fitted model, family, method, and data used (and other required information)

##  model <-   ## model name
##  family <-  ## family used, such as gaussian or poisson
##  method <-  ## method used, such as "ML" or "REML"
##  data <-    ## name of the dataset


## Then, the right-hand side of the fitted model formula must be provided (i.e., next to *resp ~ *)

##  ffun <- function(resp) {
##    gam(resp ~            ## indicate the right-hand side of the fitted model formula
##        family = family,
##        method = method,
##        data = data)
##  }


############### The hnp() syntax below can be used for all "mgcv" GAMs and GAMMs #####################

## The hnp() function can now be used to assess the adequacy of an "mgcv" object by relying on the
## three previously defined helper functions. Here, a single "hnp" iteration will be performed. Using
## the argument *how.many.out = TRUE* will allow to indicate the percentage of residuals found outside
## the simulated envelope of the half-normal plot. The corresponding half-normal plot will be shown with
## the argument *plot = TRUE*. The argument *paint = TRUE* will show in red the residuals that are found
## outside the envelope

## hnp(model,
##     newclass = TRUE, 
##     diagfun = dfun, 
##     simfun = sfun, 
##     fitfun = ffun, 
##     how.many.out = TRUE, 
##     plot = TRUE, 
##     paint = TRUE)


## The iterative process below can be used for all GAMs and GAMMs fitted in "mgcv".
## The specific dfun(), sfun(), and ffun() helper functions can be used to obtain 
## a modal and a mean percentage of residuals found outside the simulated envelope
## based on the number of iterations (n) specified by the user. A recommended 10 "hnp"
## iterations are performed below. The set.seed() function is solely used for result
## reproducibility. This code generates a list of results that are saved in an object
## referred to as *hnp_obj* below and is applicable to any model (stored as this alias)
## for which the three helper functions have been previously defined

## set.seed(2025)

## n <- 10

##  hnp_obj <- list()
##    for (i in 1:n) {
##       hnp_obj[[i]] <- hnp(model, 
##                           newclass = TRUE,
##                           diagfun = dfun,
##                           simfun = sfun,
##                           fitfun = ffun,
##                           how.many.out = TRUE,
##                           plot.sim = FALSE)
##  }


## Calculate the percentage of residuals found outside the simulated envelope of 
## each "hnp" iteration and store it in an object referred to as *hnp_summary*

hnp_summary <- sapply(hnp_obj, function(x) x$out / x$total * 100) 


## Obtain the modal percentage (asymptotic value) from the associated density curve

##  return_max <- function(numvec) {
##        dens <- density(numvec)
##        return(dens$x[which.max(dens$y)][1])
##  }

##  round(return_max(hnp_summary), 2)


## Descriptive statistics, including the mean percentage, using the Summarize() 
## function of the "FSA" package

##  Summarize(hnp_summary)


######################## GAUSSIAN DISTRIBUTION AND IDENTITY LINK #############################

## Below, a fictive GAMM for which the deviance residuals are expected to approximate a normal
## distribution and to also exhibit homoscedasticity is provided as an example

## First, simulate continuous data using the normal distribution and also assign a random effect 
## to each observation (i.e., stochastic error)

set.seed(2025)

X1 <- rnorm(n = 300)
X2 <- rnorm(n = 300)
X3 <- factor(sample(1:5, size = 300, replace = TRUE)) ## factor with 5 levels for the random effect

Y <- X1^3 + 5 * X2 + rnorm(nlevels(X3))[as.numeric(X3)] + rnorm(n = 300, mean = 1, sd = 2) 

## The simulated dataset is referred to as CONTINUOUS

CONTINUOUS <- data.frame(Y = Y,
                         X1 = X1,
                         X2 = X2,
                         X3 = X3)


## Fit a Gaussian GAMM

GAMM_GAUSSIAN <- gam(Y ~ s(X1) + X2 + s(X3, bs = "re"), 
                    family = gaussian(link = "identity"),
                    method = "REML",
                    data = CONTINUOUS) 

summary(GAMM_GAUSSIAN)


## Apply the dfun() and sfun() helper functions

dfun <- function(obj) resid(obj, type = "deviance")

sfun <- function(n, obj) simulate(obj)[, 1]


## Define the information needed for ffun()

model <- GAMM_GAUSSIAN 
family <- gaussian(link = "identity")
method <- "REML"  
data <- CONTINUOUS


## Create the model-specific ffun() function 

ffun <- function(resp) {
  gam(resp ~ s(X1) + X2 + s(X3, bs = "re"),
      family = family,
      method = method,
      data = data)
}


## Produce a single "hnp" diagnostic plot

hnp(model,
    newclass = TRUE, 
    diagfun = dfun, 
    simfun = sfun, 
    fitfun = ffun, 
    how.many.out = TRUE, 
    plot = TRUE, 
    paint = TRUE)


## Performing 10 "hnp" iterations to obtain a modal and a mean percentage of 
## residuals outside the simulated envelope

set.seed(2025)

n <- 10

hnp_obj <- list()
for (i in 1:n) {
  hnp_obj[[i]] <- hnp(model, 
                      newclass = TRUE,
                      diagfun = dfun,
                      simfun = sfun,
                      fitfun = ffun,
                      how.many.out = TRUE,
                      plot.sim = FALSE)
}

hnp_summary <- sapply(hnp_obj, function(x) x$out / x$total * 100) 

return_max <- function(numvec) {
  dens <- density(numvec)
  return(dens$x[which.max(dens$y)][1])
}


## Modal percentage of residuals outside the simulated envelope

round(return_max(hnp_summary), 2)


## Mean percentage of residuals outside the simulated envelope and other descriptive statistics

Summarize(hnp_summary)


################################ GAMMA DISTRIBUTION AND LOG LINK ##########################################

## Simulate a new continuous response variable using the Gamma distribution 
## Use the same X1, X2, and X3 as defined above, with Y requiring to be non-zero
## and only positive to allow the use of the gamma distribution and a log link.

shape <- 5
mu <- exp(1 + 1.6 * X1 - 0.8 * X2 + 2 * as.numeric(X3)) # log link
Y <- rgamma(n = 300, shape = shape, rate = shape / mu)


## The dataset *NON_ZERO_POSITIVE_CONTINUOUS* is created to be analyzed with the gamma distribution (log link)

NON_ZERO_POSITIVE_CONTINUOUS <- data.frame(Y = Y,
                                           X1 = X1,
                                           X2 = X2,
                                           X3 = X3)

GAMM_GAMMA <- gam(Y ~ s(X1) + X2 + s(X3, bs = "re"), 
                  family = Gamma(link = "log"), 
                  method = "REML", 
                  data = NON_ZERO_POSITIVE_CONTINUOUS)

summary(GAMM_GAMMA)


## Apply the dfun() and sfun() functions

dfun <- function(obj) resid(obj, type = "deviance")

sfun <- function(n, obj) simulate(obj)[, 1]


## Define the information needed for ffun()

model <- GAMM_GAMMA
family <- Gamma(link = "log")
method <- "REML"  
data <- NON_ZERO_POSITIVE_CONTINUOUS


## Create the model-specific ffun() function

ffun <- function(resp) {
  gam(resp ~ s(X1) + X2 + s(X3, bs = "re"),
      family = family,
      method = method,
      data = data)
}


## Produce a single "hnp" diagnostic plot

hnp(model,
    newclass = TRUE,
    diagfun = dfun,
    simfun = sfun,
    fitfun = ffun,
    how.many.out = TRUE,
    plot = TRUE,
    paint = TRUE)


## 10 hnp iterations to get a modal and mean percentage

set.seed(2025)

n <- 10

hnp_obj <- list()
for (i in 1:n) {
  hnp_obj[[i]] <- hnp(model, 
                      newclass = TRUE,
                      diagfun = dfun,
                      simfun = sfun,
                      fitfun = ffun,
                      how.many.out = TRUE,
                      plot.sim = FALSE)
}

hnp_summary <- sapply(hnp_obj, function(x) x$out / x$total * 100) 

return_max <- function(numvec) {
  dens <- density(numvec)
  return(dens$x[which.max(dens$y)][1])
}

round(return_max(hnp_summary), 2)

Summarize(hnp_summary)


################################# POISSON DISTRIBUTION AND LOG LINK #########################################

## Simulate overdispersed counts (variance > mean) from the NB2 distribution to illustrate that the Poisson
## distribution is inadequate to model such data, using again the same predictor X1, X2, and X3 as above

set.seed(2025)

mu <- exp(1 + 2* X1 - 1.5 * X2 + 0.38 * as.numeric(X3))  # log link

Y <- rnbinom(n = 300, mu = mu, size = 3)

COUNT <- data.frame(Y = Y,
                    X1 = X1,
                    X2 = X2,
                    X3 = X3)

GAMM_POISSON <- gam(Y ~ s(X1) + X2 + s(X3, bs = "re"), 
                     family = poisson, ## same as family = poisson(link = "log")
                     method = "REML",
                     data = COUNT) 

summary(GAMM_POISSON)

dfun <- function(obj) resid(obj, type = "deviance")

sfun <- function(n, obj) simulate(obj)[, 1]

model <- GAMM_POISSON 
family <- poisson
method <- "REML"  
data <- COUNT

ffun <- function(resp) {
  gam(resp ~ s(X1) + X2 + s(X3, bs = "re"),
      family = family,
      method = method,
      data = data)
}

hnp(model,
    newclass = TRUE, 
    diagfun = dfun, 
    simfun = sfun, 
    fitfun = ffun, 
    how.many.out = TRUE, 
    plot = TRUE, 
    paint = TRUE)


## 10 hnp iterations to get a modal and mean percentage

set.seed(2025)

n <- 10

hnp_obj <- list()
for (i in 1:n) {
  hnp_obj[[i]] <- hnp(model, 
                      newclass = TRUE,
                      diagfun = dfun,
                      simfun = sfun,
                      fitfun = ffun,
                      how.many.out = TRUE,
                      plot.sim = FALSE)
}

hnp_summary <- sapply(hnp_obj, function(x) x$out / x$total * 100) 

return_max <- function(numvec) {
  dens <- density(numvec)
  return(dens$x[which.max(dens$y)][1])
}

round(return_max(hnp_summary), 2)

Summarize(hnp_summary)


################################# TYPE-II NEGATIVE BINOMIAL (NB2) WITH LOG LINK ##################################

## Here the same dataset (COUNT) that was analyzed above with the Poisson distribution is now modeled with
## a NB2 GAMM

GAMM_NB2 <- gam(Y ~ s(X1) + X2 + s(X3, bs = "re"), 
                    family = nb, ## same as family = nb(theta = NULL, link = "log")
                    method = "REML",
                    data = COUNT) ## same COUNT data as in the Poisson example above

summary(GAMM_NB2)


dfun <- function(obj) resid(obj, type = "deviance")

sfun <- function(n, obj) simulate(obj)[, 1]

model <- GAMM_NB2 
family <- nb
method <- "REML"  
data <- COUNT

ffun <- function(resp) {
  gam(resp ~ s(X1) + X2 + s(X3, bs = "re"), 
      family = family,
      method = method,
      data = data)
}

hnp(model,
    newclass = TRUE, 
    diagfun = dfun, 
    simfun = sfun, 
    fitfun = ffun, 
    how.many.out = TRUE, 
    plot = TRUE, 
    paint = TRUE)


## 10 hnp iterations to get a modal and mean percentage

set.seed(2025)

n <- 10

hnp_obj <- list()
for (i in 1:n) {
  hnp_obj[[i]] <- hnp(model, 
                      newclass = TRUE,
                      diagfun = dfun,
                      simfun = sfun,
                      fitfun = ffun,
                      how.many.out = TRUE,
                      plot.sim = FALSE)
}

hnp_summary <- sapply(hnp_obj, function(x) x$out / x$total * 100) 

return_max <- function(numvec) {
  dens <- density(numvec)
  return(dens$x[which.max(dens$y)][1])
}

round(return_max(hnp_summary), 2)

Summarize(hnp_summary)


## The Poisson model was inadequate to model such overdispersed data. whereas the NB2 GAMM is barely $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ 
## adequate based on the modal percentage of deviance residuals found outside the simulated envelope. $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ 


############################# BINOMIAL DISTRIBUTION AND LOGIT LINK (discrete proportions) ##############################

## Generate discrete proportions

set.seed(2025)

X1 <- runif(n = 300) # random numbers between 0 and 1
X2 <- rnorm(n = 300)
X3 <- factor(sample(1:7, size = 300, replace = TRUE))
TOTAL <- sample(5:20, size = 300, replace = TRUE)

eta <- 0.4 + X1^3 + 1.5 * X2 - 0.6 * as.numeric(X3)  ## systematic component using X1, X2, and X3 defined above 
p <- 1 / (1 + exp(-eta))                             ## probabilities
p_star <- pmin(pmax(p, 1e-6), 1 - 1e-6)              ## avoid probabilities of exactly 0 or 1

YES <- rbinom(n = 300, size = TOTAL, prob = p_star)

DISCRETE_PROP <- data.frame(YES = YES,
                            TOTAL = TOTAL,
                            X1 = X1,
                            X2 = X2,
                            X3 = X3)

GAMM_BINOMIAL_LOGIT <- gam(cbind(YES, TOTAL - YES) ~ s(X1) + X2 + s(X3, bs = "re"), 
                           family = binomial(link = "logit"),        ## same as family = binomial
                           method = "REML",
                           data = DISCRETE_PROP) 

summary(GAMM_BINOMIAL_LOGIT)


## For discrete proportions, *size* (i.e., the denominator) must also be provided within the simulation function.
## In this fictive dataset (DISCRETE_PROP), *size* makes up the TOTAL variable.

dfun <- function(obj) resid(obj, type = "deviance")

## Note below that the sfun() function has changed

sfun <- function(n, obj) round(simulate(obj)[, 1] * size, 0)

model <- GAMM_BINOMIAL_LOGIT
family <- binomial
method <- "REML"  
data <- DISCRETE_PROP
size <- DISCRETE_PROP$TOTAL

ffun <- function(new_response) {
  gam(cbind(new_response, TOTAL - new_response) ~ s(X1) + X2 + s(X3, bs = "re"),
      family = family,
      method = method,
      data = data)
}

hnp(model,
    newclass = TRUE, 
    diagfun = dfun, 
    simfun = sfun, 
    fitfun = ffun, 
    how.many.out = TRUE, 
    plot = TRUE, 
    paint = TRUE)


## 10 hnp iterations to get a modal and mean percentage

set.seed(2025)

n <- 10

hnp_obj <- list()
for (i in 1:n) {
  hnp_obj[[i]] <- hnp(model, 
                      newclass = TRUE,
                      diagfun = dfun,
                      simfun = sfun,
                      fitfun = ffun,
                      how.many.out = TRUE,
                      plot.sim = FALSE)
}

hnp_summary <- sapply(hnp_obj, function(x) x$out / x$total * 100) 

return_max <- function(numvec) {
  dens <- density(numvec)
  return(dens$x[which.max(dens$y)][1])
}

round(return_max(hnp_summary), 2)

Summarize(hnp_summary)

