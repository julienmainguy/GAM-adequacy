## Required packages:

library(FSA)
library(hnp)
library(mgcv)

###########################################################################################
######################## "hnp" helper functions for "mgcv" ################################
###########################################################################################

## Helper functions are now available to allow the adequacy assessment of GAMs fitted in 
## "mgcv". These are the dfun(), sfun(), and ffun() functions, which are all described below,
## knowing that:
##   - the dfun() function remains the same at all times
##   - the sfun() function remains the same in all cases, except for the binomial distribution
##   - the ffun() function has to be adapted each time to how the model was specified


## dfun(): a helper function to extract the deviance (or other types of) residuals of a model.

dfun <- function(obj) resid(obj, type = "deviance")


## sfun(): a helper function to perform empirically-derived simulations to determine
## how the residuals should behave under the distributional assumptions of the fitted GAM.
## For the Gaussian (identity link), gamma (log link), Poisson (log link) and NB2 (log link),
## the sfun() function is exactly the same. For the specific case of the binomial distribution
## when analyzing discrete proportion data (i.e., not binary data), a different sfun() function
## is required

## Gaussian, gamma with log link, Poisson, and NB2

sfun <- function(n, obj) simulate(obj)[,1]


## binomial with discrete proportions

sfun <- function(n, obj) round(simulate(obj)[,1] * size, 0)


## ffun(): a helper function to refit the model 99 times (default value). 
## This function is also specific to the model being assessed

## First, define the fitted model, family, method, and data used (and other required information)

model <-   ## model name
family <-  ## family used, such as poisson or nb (i.e., NB2)
method <-  ## method used, such as "ML" or "REML"
data <-    ## name of dataset


## Then, the right-hand side of the fitted model formula must be provided (i.e., next to *resp ~ *)

ffun <- function(resp) {
  gam(resp ~            ## indicate the right-hand side of the fitted model formula
      family = family,
      method = method,
      data = data)
}


###################### The hnp() syntax below can be used for all "mgcv" GAMs and GAMMs #############################

## The hnp() function can now be used to assess the adequacy of an "mgcv" object
## by relying on the three previously defined helper functions. Here, a single "hnp" iteration
## will be performed. The argument how.many.out = TRUE will indicate the percentage of residuals
## found outside the simulated envelope of the half-normal plot. The corresponding
## half-normal plot will be shown with the argument plot = TRUE. The argument
## paint = TRUE will show the residuals found outside the envelope in red. The
## code below is just provided as an example and thus, will not work if run.

hnp(model,                 ## same as the GAM or GAMM that was defined above
    newclass = TRUE, 
    diagfun = dfun, 
    simfun = sfun, 
    fitfun = ffun, 
    how.many.out = TRUE, 
    plot = TRUE, 
    paint = TRUE)


## The iterative process below can be used for all GAMs and GAMMs fitted in "mgcv".
## The specific dfun(), sfun(), and ffun() helper functions can be used to obtain 
## a modal and a mean percentage of residuals found outside the simulated
## envelope based on the number of iterations (n) specified by the user.
## 10 "hnp" iterations are performed below. The set.seed() function is solely
## used for result reproducibility. This code generates a list of results
## saved as an object called "hnp_obj" below and is applicable to any model (stored 
## as this alias) for which the dfun(), sfun(), and ffun() helper functions 
## have been previously correctly defined.

set.seed(2025)

n <- 10

hnp_obj <- list()
for (i in 1:n) {
  hnp_obj[[i]] <- hnp(model, 
                      newclass = TRUE,
                      diagfun = dfun,
                      simfun = sfun,
                      fitfun = ffun,
                      how.many.out = TRUE,
                      plot.sim = FALSE)
}


## Calculate the percentage of residuals found outside the simulated envelope of 
## each "hnp" iteration and store it in an object referred to as hnp_summary

hnp_summary <- sapply(hnp_obj, function(x) x$out / x$total * 100) 


## Obtain the mode percentage (asymptotic value) from the associated density curve

return_max <- function(numvec) {
  dens <- density(numvec)
  return(dens$x[which.max(dens$y)][1])
}

round(return_max(hnp_summary), 2)


## Descriptive statistics, including the mean percentage, using the Summarize() 
## function of the "FSA" package

Summarize(hnp_summary)


##################################### GAUSSIAN DISTRIBUTION AND IDENTITY LINK ##########################################

## Below, a fictive GAMM for which the deviance residuals are expected to
## approximate a normal distribution (and to be homoscedastic) is provided as an example.

## Simulate continuous data using the normal distribution
## Also assign random effect to each observation (stochastic error)

set.seed(2025)

X1 <- rnorm(n = 300)
X2 <- rnorm(n = 300)
X3 <- factor(sample(1:5, size = 300, replace = TRUE)) ## factor with 5 levels for the random effect

Y <- X1^3 + 5 * X2 + rnorm(nlevels(X3))[as.numeric(X3)] + rnorm(n = 300, mean = 1, sd = 2) 

## The simulated dataset is referred to as CONTINUOUS

CONTINUOUS <- data.frame(Y = Y,
                         X1 = X1,
                         X2 = X2,
                         X3 = X3)


## Fit a Gaussian GAMM

GAMM_GAUSSIAN <- gam(Y ~ s(X1) + X2 + s(X3, bs = "re"), 
                    family = gaussian(link = "identity"),
                    method = "REML",
                    data = CONTINUOUS) 

summary(GAMM_GAUSSIAN)

## Apply the dfun() and sfun() helper functions

dfun <- function(obj) resid(obj, type = "deviance")
sfun <- function(n, obj) simulate(obj)[,1]


## Define the information needed for ffun()

model <- GAMM_GAUSSIAN 
family <- gaussian(link = "identity")
method <- "REML"  
data <- CONTINUOUS


## Apply the model-specific ffun() function 

ffun <- function(resp) {
  gam(resp ~ s(X1) + X2 + s(X3, bs = "re"),
      family = family,
      method = method,
      data = data)
}


## Produce a single "hnp" diagnostic plot

hnp(model,
    newclass = TRUE, 
    diagfun = dfun, 
    simfun = sfun, 
    fitfun = ffun, 
    how.many.out = TRUE, 
    plot = TRUE, 
    paint = TRUE)


## Performing 10 "hnp" iterations to obtain a modal and a mean percentage of 
## residuals outside the simulated envelope

set.seed(2025)

n <- 10

hnp_obj <- list()
for (i in 1:n) {
  hnp_obj[[i]] <- hnp(model, 
                      newclass = TRUE,
                      diagfun = dfun,
                      simfun = sfun,
                      fitfun = ffun,
                      how.many.out = TRUE,
                      plot.sim = FALSE)
}

hnp_summary <- sapply(hnp_obj, function(x) x$out / x$total * 100) 

return_max <- function(numvec) {
  dens <- density(numvec)
  return(dens$x[which.max(dens$y)][1])
}

## Modal percentage of residuals outside the simulated envelope

round(return_max(hnp_summary), 2)

## Mean percentage of residuals outside the simulated envelope

Summarize(hnp_summary)


################################ GAMMA DISTRIBUTION AND LOG LINK ##########################################

## Simulate a new continuous response variable using the Gamma distribution 
## Use the same X1, X2, and X3 as defined above, with Y requiring to be non-zero
## and only positive to allow the use of the gamma distribution and a log link.

shape <- 5
mu <- exp(1 + 1.6 * X1 - 0.8 * X2 + 2 * as.numeric(X3)) # log link
Y <- rgamma(n = 300, shape = shape, rate = shape / mu)

NON_ZERO_POSITIVE_CONTINUOUS <- data.frame(Y = Y,
                                           X1 = X1,
                                           X2 = X2,
                                           X3 = X3)

GAMM_GAMMA <- gam(Y ~ s(X1) + X2 + s(X3, bs = "re"), 
                  family = Gamma(link = "log"), 
                  method = "REML", 
                  data = NON_ZERO_POSITIVE_CONTINUOUS)

summary(GAMM_GAMMA)


dfun <- function(obj) resid(obj, type = "deviance")
sfun <- function(n, obj) simulate(obj)[,1]

model <- GAMM_GAMMA
family <- Gamma(link = "log")
method <- "REML"  
data <- NON_ZERO_POSITIVE_CONTINUOUS

ffun <- function(resp) {
  gam(resp ~ s(X1) + X2 + s(X3, bs = "re"),
      family = family,
      method = method,
      data = data)
}

hnp(model,
    newclass = TRUE, 
    diagfun = dfun, 
    simfun = sfun, 
    fitfun = ffun, 
    how.many.out = TRUE, 
    plot = TRUE, 
    paint = TRUE)


## 10 hnp iterations to get a modal and mean percentage

set.seed(2025)

n <- 10

hnp_obj <- list()
for (i in 1:n) {
  hnp_obj[[i]] <- hnp(model, 
                      newclass = TRUE,
                      diagfun = dfun,
                      simfun = sfun,
                      fitfun = ffun,
                      how.many.out = TRUE,
                      plot.sim = FALSE)
}

hnp_summary <- sapply(hnp_obj, function(x) x$out / x$total * 100) 

return_max <- function(numvec) {
  dens <- density(numvec)
  return(dens$x[which.max(dens$y)][1])
}

round(return_max(hnp_summary), 2)

Summarize(hnp_summary)


################################# POISSON DISTRIBUTION AND LOG LINK #########################################

## Simulate data from the type-II negative binomial (NB2) distribution to 
## illustrate that the Poisson distribution is inadequate to model such overdispersed
## count data.

set.seed(2025)

## use the same predictor X1, X2, and X3 as above

mu <- exp(1 + 2* X1 - 1.5 * X2 + 0.38 * as.numeric(X3))  # log link

Y <- rnbinom(n = 300, mu = mu, size = 3)

COUNT <- data.frame(Y = Y,
                    X1 = X1,
                    X2 = X2,
                    X3 = X3)

GAMM_POISSON <- gam(Y ~ s(X1) + X2 + s(X3, bs = "re"), 
                     family = poisson, ## same as family = poisson(link = "log")
                     method = "REML",
                     data = COUNT) 

summary(GAMM_POISSON)

dfun <- function(obj) resid(obj, type = "deviance")
sfun <- function(n, obj) simulate(obj)[,1]

model <- GAMM_POISSON 
family <- poisson
method <- "REML"  
data <- COUNT

ffun <- function(resp) {
  gam(resp ~ s(X1) + X2 + s(X3, bs = "re"),
      family = family,
      method = method,
      data = data)
}

hnp(model,
    newclass = TRUE, 
    diagfun = dfun, 
    simfun = sfun, 
    fitfun = ffun, 
    how.many.out = TRUE, 
    plot = TRUE, 
    paint = TRUE)


## 10 hnp iterations to get a modal and mean percentage

set.seed(2025)

n <- 10

hnp_obj <- list()
for (i in 1:n) {
  hnp_obj[[i]] <- hnp(model, 
                      newclass = TRUE,
                      diagfun = dfun,
                      simfun = sfun,
                      fitfun = ffun,
                      how.many.out = TRUE,
                      plot.sim = FALSE)
}

hnp_summary <- sapply(hnp_obj, function(x) x$out / x$total * 100) 

return_max <- function(numvec) {
  dens <- density(numvec)
  return(dens$x[which.max(dens$y)][1])
}

round(return_max(hnp_summary), 2)

Summarize(hnp_summary)


################################# TYPE-II NEGATIVE BINOMIAL (NB2) WITH LOG LINK ##################################

GAMM_NB2 <- gam(Y ~ s(X1) + X2 + s(X3, bs = "re"), 
                    family = nb, ## same as family = nb(theta = NULL, link = "log")
                    method = "REML",
                    data = COUNT) ## same COUNT data as in the Poisson example above

summary(GAMM_NB2)

dfun <- function(obj) resid(obj, type = "deviance")
sfun <- function(n, obj) simulate(obj)[,1]

model <- GAMM_NB2 
family <- nb
method <- "REML"  
data <- COUNT

ffun <- function(resp) {
  gam(resp ~ s(X1) + X2 + s(X3, bs = "re"), 
      family = family,
      method = method,
      data = data)
}

hnp(model,
    newclass = TRUE, 
    diagfun = dfun, 
    simfun = sfun, 
    fitfun = ffun, 
    how.many.out = TRUE, 
    plot = TRUE, 
    paint = TRUE)


## 10 hnp iterations to get a modal and mean percentage

set.seed(2025)

n <- 10

hnp_obj <- list()
for (i in 1:n) {
  hnp_obj[[i]] <- hnp(model, 
                      newclass = TRUE,
                      diagfun = dfun,
                      simfun = sfun,
                      fitfun = ffun,
                      how.many.out = TRUE,
                      plot.sim = FALSE)
}

hnp_summary <- sapply(hnp_obj, function(x) x$out / x$total * 100) 

return_max <- function(numvec) {
  dens <- density(numvec)
  return(dens$x[which.max(dens$y)][1])
}

round(return_max(hnp_summary), 2)

Summarize(hnp_summary)


## The Poisson model was inadequate to model such overdispersed data. whereas the NB2 GAMM is sufficiently 
## adequate based on the modal percentage of deviance residuals found outside the simulated envelope. 


############################# BINOMIAL DISTRIBUTION AND LOGIT LINK (discrete proportions) ##############################

## Generate new data

set.seed(2025)

X1 <- runif(n = 300) # random numbers between 0 and 1
X2 <- rnorm(n = 300)
X3 <- factor(sample(1:7, size = 300, replace = TRUE))
TOTAL <- sample(5:20, size = 300, replace = TRUE)

eta <- 0.4 + X1^3 + 1.5 * X2 - 0.6 * as.numeric(X3) # systematic component using X1, X2, and X3 defined above 
p <- 1 / (1 + exp(-eta))                            # probabilities
p_star <- pmin(pmax(p, 1e-6), 1 - 1e-6)             # avoid probabilities of exactly 0 or 1

YES <- rbinom(n = 300, size = TOTAL, prob = p_star)

DISCRETE_PROP <- data.frame(YES = YES,
                            TOTAL = TOTAL,
                            X1 = X1,
                            X2 = X2,
                            X3 = X3)

GAMM_BINOMIAL_LOGIT <- gam(cbind(YES, TOTAL - YES) ~ s(X1) + X2 + s(X3, bs = "re"), 
                           family = binomial(link = "logit"),        ## same as family = binomial
                           method = "REML",
                           data = DISCRETE_PROP) 

summary(GAMM_BINOMIAL_LOGIT)


## For discrete proportions, size (i.e., the denominator) must also be provided
## within the simulation function. In this fictive dataset (DISCRETE_PROP), size
## makes up the TOTAL variable.

model <- GAMM_BINOMIAL_LOGIT
family <- binomial
method <- "REML"  
data <- DISCRETE_PROP
size <- DISCRETE_PROP$TOTAL

dfun <- function(obj) resid(obj, type = "deviance")

sfun <- function(n, obj) round(simulate(obj)[,1] * size, 0)

ffun <- function(new_response) {
  gam(cbind(new_response, TOTAL - new_response) ~ s(X1) + X2 + s(X3, bs = "re"),
      family = family,
      method = method,
      data = data)
}

hnp(model,
    newclass = TRUE, 
    diagfun = dfun, 
    simfun = sfun, 
    fitfun = ffun, 
    how.many.out = TRUE, 
    plot = TRUE, 
    paint = TRUE)


## 10 hnp iterations to get a modal and mean percentage

set.seed(2025)

n <- 10

hnp_obj <- list()
for (i in 1:n) {
  hnp_obj[[i]] <- hnp(model, 
                      newclass = TRUE,
                      diagfun = dfun,
                      simfun = sfun,
                      fitfun = ffun,
                      how.many.out = TRUE,
                      plot.sim = FALSE)
}

hnp_summary <- sapply(hnp_obj, function(x) x$out / x$total * 100) 

return_max <- function(numvec) {
  dens <- density(numvec)
  return(dens$x[which.max(dens$y)][1])
}

round(return_max(hnp_summary), 2)

Summarize(hnp_summary)

