###############################################################################################
######################## "hnp" helper functions for "mgcv" ####################################
###############################################################################################

## NOTE
## Only explanations about the use of the helper functions for "hnp" are provided below, such
## that the application of these helper functions with "hnp" can be done with the examples that
## are described in the main text (i.e., TROUT, WALLEYE, and CHARR data) with the code made
## available here in the same repository (i.e., GAM-adequacy).

## The "hnp" package cannot currently be used to assess the adequacy of GAMs fitted in "mgcv".
## Three helper functions, namely dfun(), sfun(), and ffun(), can jointly be employed to allow
## to make this possible, therefore providing an additional adequacy assessment tool for "mgcv".

## The dfun() function extracts the deviance (or other types of) residuals of a given GAM.
## This first function remains the same at all times and is coded as follows:

dfun <- function(obj) resid(obj, type = "deviance")


## The sfun() function allows to perform simulations to determine how the residuals should behave
## under the distributional assumptions of the fitted GAM. Each distribution family has its own
## sfun() function, with commonly-used ones listed below with their respective sfun() functions:

## Gaussian distribution with an identity link [continuous data]

sfun <- function(n, obj) {
  y <- rnorm(nrow(data),
             mean = predict(model, type = "response"),
             sd = sqrt(model$sig2))
   return(y)
}


## Gamma distribution with a log link [nonzero-positive continuous data]

sfun <- function(n, obj) {
  mu_hat <- fitted(obj)
  phi <- summary(obj)$dispersion
  shape <- 1 / phi
  scale <- mu_hat * phi
  y <- rgamma(n = length(mu_hat), shape = shape, scale = scale)
  return(y)
}


## Poisson distribution with a log link [counts]

sfun <- function(n,obj) {
  y <- rpois(nrow(data),
             lambda = predict(model, type = "response"))
  return(y)
 }


## Type-II negative binomial (NB2) distribution with a log link [counts]

sfun <- function(n,obj) {
  y <- rnbinom(nrow(data),
               size = model$family$getTheta(TRUE),
               mu = predict(model, type = "response"))
  return(y)
}


## Binomial distribution with logit, probit, or cloglog link [discrete proportions]
## NOTE: A binomial GAM analyzing binary data [e.g., 0/1] cannot be assessed with "hnp"

sfun <- function(n, obj) {
  p_hat <- predict(obj, type = "response")
  y <- rbinom(n = n,
              size = size,
              prob = p_hat)
  return(y)
}


## The ffun() function refits the considered GAM 99 times (default value) and this information
## will then be used in the hnp() function of "hnp" to yield a half-normal plot with a simulated
## envelope for adequacy assessment purposes. The ffun() function is specific to the fitted GAM.

## The following steps must be followed:

## First, define the specifications of the fitted model for later use with the helper functions

##  model <-   ## model's name
##  family <-  ## family used, such as Gamma(link = "log") following the syntax of "mgcv"
##  method <-  ## method used, such as "ML" or "REML"
##  data <-    ## name of the dataset


## Apply the dfun() function:

## dfun <- function(obj) resid(obj, type = "deviance")


## Apply the sfun() function that is specific to the (distribution) family used (see above)

## sfun <- function(n, obj) {
##    ####################### ## SPECIFIC TO THE DISTRIBUTION FAMILY BEING CONSIDERED
##    return(y)
## }


## Then, the right-hand side of the fitted model formula must be provided (i.e., next to *resp ~ *)
## for the ffun() function to properly work. For example, if the model analyzes a response variable (Y) 
## according to a fixed smooth term, s(X1), and a random effect, X2, then the fitted model would be:
## Y ~ s(X1) + s(X2, bs = "re") and the right-hand side therefore be s(X1) + s(X2, bs = "re"):

##  ffun <- function(resp) {
##    gam(resp ~ s(X1) + s(X2, bs = "re") ## INSERT HERE, AS AN EXAMPLE
##        family = family,                ## as defined above
##        method = method,                ## as defined above
##        data = data)                    ## as defined above
##  }


## The hnp() function can now be used to assess the adequacy of a GAM fitted with "mgcv" by relying on 
## the three previously defined helper functions. Here, a single "hnp" iteration will be performed. Using
## the argument *how.many.out = TRUE* will allow to indicate the percentage of residuals found outside
## the simulated envelope of the half-normal plot. The corresponding half-normal plot will be shown with
## the argument *plot = TRUE*. The argument *paint = TRUE* will show in red the residuals that are found
## outside the simulated envelope.

## hnp(model,
##     newclass = TRUE, 
##     diagfun = dfun, 
##     simfun = sfun, 
##     fitfun = ffun, 
##     how.many.out = TRUE, 
##     plot = TRUE, 
##     paint = TRUE)


## Because the envelope is based on simulations, its lower and upper limits can slightly
## vary from one "hnp" iteration to another. To obtain a more reliable assessment of the
## model fit according its underlying distributional assumptions, it is preferable to
## perform many iterations from which a modal or mean percentage of residuals found 
## outside the envelope is calculated. The number of iteration (n) recommended is n = 10,
## as used below, since this process can be computationally intensive with complex models,
## such as with mixed-effects GAMs in which many smooth terms are included. The code below
## first generate a list of results that are saved in an object referred to as *hnp_obj*.
## The set.seed() function is solely used for result reproducibility.

## set.seed(2025)

## n <- 10

## hnp_obj <- list()
##    for (i in 1:n) {
##       hnp_obj[[i]] <- hnp(model, 
##                           newclass = TRUE,
##                           diagfun = dfun,
##                           simfun = sfun,
##                           fitfun = ffun,
##                           how.many.out = TRUE,
##                           plot.sim = FALSE)
## }


## The percentage of residuals found outside the simulated envelope is calculated for each 
## "hnp" iteration (here n = 10) and then stored in an object referred to as *hnp_summary*:

## hnp_summary <- sapply(hnp_obj, function(x) x$out / x$total * 100) 


## The modal percentage (asymptotic value) from the associated density curve is first obtained:

##  return_max <- function(numvec) {
##        dens <- density(numvec)
##        return(dens$x[which.max(dens$y)][1])
##  }
##  round(return_max(hnp_summary), 2)


## The descriptive statistics, including the mean percentage, is also obtained using the Summarize() 
## function of "FSA":

##  Summarize(hnp_summary)

