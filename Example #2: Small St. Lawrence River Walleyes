## Required packages:

library(FSA)
library(hnp)
library(itsadug)
library(mgcv)
library(mgcViz)
library(MuMIn)
library(performance)
library(tidyverse)


## Create a function for the calculation of the sample-adjusted BIC (BICc)

BICc <- function (obj) {
  bic <- BIC(obj)
  n <- obj$df.null + 1
  p <- n - obj$df.residual
  bicc <- bic + (log(n) * (p + 1) * p)/(n - p - 1)
  return(bicc)
}


################################################################################
#### EXAMPLE 2: CPUE TEMPORAL TREND OF SMALL ST. LAWRENCE RIVER WALLEYES #######
################################################################################

## Load the WALLEYE dataset as an example with counts 

file_name <- 
"https://raw.githubusercontent.com/julienmainguy/GAM-adequacy/main/WALLEYE"

WALLEYE <- read.delim(file_name)


################### GENERALIZED ADDITIVE MIXED-EFFECTS MODELING (GAMM) ######################

## Poisson GAMM with the default settings for the smooth function, s(), for all
## predictors, i.e., the use of thin-plate regression splines (bs = "tp") and k = 10, with
## Maximum Likelihood (ML) estimation and AREA fitted as a random effect in "mgcv".

WALLEYE$AREA <- as.factor(WALLEYE$AREA)

m_WALLEYE_POISSON_FULL <- gam(N ~ s(YEAR) + s(CONDUCT) + s(D1AUG) + s(DEPTH)
                              + s(EFFORT) + s(TEMP) + s(TURBID) + s(AREA, bs = "re"),
                              family = poisson,
                              method = "ML",
                              data = WALLEYE)

summary(m_WALLEYE_POISSON_FULL)


## Check for likely overdispersion issues (see text) in the Poisson GAMM.

check_overdispersion(m_WALLEYE_POISSON_FULL)


## Check for zero-inflation issues (see text) in the Poisson GAMM.

check_zeroinflation(m_WALLEYE_POISSON_FULL)


## The fully-parameterized Poisson GAMM is not modeling sufficiently equi-dispersed
## counts and is probably underfitting zeros, such that it cannot be considered as being
## adequate and is thus discarded. This can be easily confirmed by looking at a single
## half-normal plot with a simulated envelope. This can take many seconds to run. Using
## 10 iterations instead (not shown) just simply confirm the complete inadequacy of this
## Poisson GAMM, but a sole diaganotic plot suffices in such case, as done below.

model <- m_WALLEYE_POISSON_FULL
family <- poisson
method <- "ML"
data <- WALLEYE

dfun <- function(obj) resid(obj, type = "deviance")

sfun <- function(n,obj) {
  y <- rpois(nrow(data),
             lambda = predict(model, type = "response"))
  return(y)
 }

ffun <- function(resp) {
      gam(resp ~ s(YEAR) + D1AUG + DEPTH + s(TURBID) + s(AREA, bs = "re"),
          family = family,
          method = method,
          data = data)
}

hnp(model,
    newclass = TRUE,
    diagfun = dfun,
    simfun = sfun,
    fitfun = ffun,
    how.many.out = TRUE,
    plot.sim = TRUE,
    paint = TRUE,
    ylab = "Deviance residuals")


## The type-II negative binomial (NB2) extension is used instead in an attempt to handle
## both the confirmed overdispersion and the plausible zero-inflation.

m_WALLEYE_NB2_FULL <- gam(N ~ s(YEAR) + s(CONDUCT) + s(D1AUG) + s(DEPTH) +
                          s(EFFORT) + s(TEMP) + s(TURBID) + s(AREA, bs = "re"),
                          family = nb,
                          method = "ML",
                          data = WALLEYE)

summary(m_WALLEYE_NB2_FULL)


## To first determine whether this NB2 GAMM fitted in "mgcv" could be reduced by
## excluding some predictors that may explain little to no variation in the response
## variable, a variable-selection approach which more heavily penalizes each smooth
## term with the argument select = TRUE will be used.

m_WALLEYE_NB2_SELECT <- gam(N ~ s(YEAR) + s(CONDUCT) + s(D1AUG) + s(DEPTH) +
                            s(EFFORT) + s(TEMP) + s(TURBID) + s(AREA, bs = "re"),
                            family = nb,
                            method = "ML",
                            select = TRUE,
                            data = WALLEYE)

summary(m_WALLEYE_NB2_SELECT)


## The predictors s(CONDUCT), s(EFFORT), and s(TEMP) have their respective
## effective degrees of freedom (edf) shrinking toward zero, indicating that
## these three covariates fitted as smooth terms can be discarded. The NB2 GAMM
## is refitted without these predictors and referred to as m_WALLEYE_NB2_REDUCED.

m_WALLEYE_NB2_REDUCED <- gam(N ~ s(YEAR) + s(D1AUG) + s(DEPTH) + s(TURBID) +
                                  s(AREA, bs = "re"),
                                  family = nb,
                                  method = "ML",
                                  data = WALLEYE)

summary(m_WALLEYE_NB2_REDUCED)


## The smooth terms s(D1AUG) and s(DEPTH) now both exhibit edf = 1, indicating 
## that both predictors can be included as parametric components instead. A final
## NB2 GAMM is thus fitted with fewer smooth terms.

m_WALLEYE_NB2_FINAL <- gam(N ~ s(YEAR) + D1AUG + DEPTH + s(TURBID) +
                           s(AREA, bs = "re"),
                           family = nb,
                           method = "ML",
                           data = WALLEYE)

summary(m_WALLEYE_NB2_FINAL)


## Check if overdispersion and zero-inflation were sufficiently accounted for in
## the retained final NB2 GAMM, which can only be done for the one built in 
## "mgcv" when the NB2 extension is used. Note that for the zero-inflation test,
## a p-value is provided when the NB2 extension is used.

check_overdispersion(m_WALLEYE_NB2_FINAL)

check_zeroinflation(m_WALLEYE_NB2_FINAL)


############################### FINAL NB2 GAMM ADEQUACY ###################################

## Diagnostic plots with the gam.check() function of "mgcv". Note how the residual pattern
## in the top-right plot (Resids vs. linear pred.) are nearly uninterpretable due to the 
## discreteness of the data being modeled.

gam.check(m_WALLEYE_NB2_FINAL)


## Adequacy assessment based on half-normal plots with "hnp". 
## This can take many seconds to a few minutes to run

model <- m_WALLEYE_NB2_FINAL     ## this step can take many minutes
family <- nb
method <- "ML"
data <- WALLEYE

dfun <- function(obj) resid(obj, type = "deviance")

sfun <- function(n,obj) {
  y <- rnbinom(nrow(data),
               size = model$family$getTheta(TRUE),
               mu = predict(model, type = "response"))
  return(y)
}

ffun <- function(resp) {
      gam(resp ~ s(YEAR) + D1AUG + DEPTH + s(TURBID) + s(AREA, bs = "re"),
          family = family,
          method = method,
          data = data)
}


## 1 run to produce 1 half-normal plot only
## This can take many seconds to run given the GAMM's complexity.

hnp(model,
    newclass = TRUE,
    diagfun = dfun,
    simfun = sfun,
    fitfun = ffun,
    how.many.out = TRUE,
    plot.sim = TRUE,
    paint = TRUE,
    ylab = "Deviance residuals")


## 10 "hnp" runs to get a mode and mean % of residuals outside the simulated
## envelope. This can take many minutes to run given the GAMM's level of complexity.

set.seed(2025)

n <- 10

hnp_obj <- list()
for(i in 1:n) {
  hnp_obj[[i]] <- hnp(model,
                   newclass = TRUE,
                   diagfun = dfun,
                   simfun = sfun,
                   fitfun = ffun,
                   how.many.out = TRUE,
                   plot.sim = FALSE)
}

hnp_summary <- sapply(hnp_obj, function(x) x$out/x$total*100) 

return_max <- function(numvec) {
  dens <- density(numvec)
  return(dens$x[which.max(dens$y)][1])
}
round(return_max(hnp_summary), 2)

Summarize(hnp_summary)


## Calculate the mgcViz score (mean) based on 100 iterations, each relying on 100 
## model-based simulations, for m_WALLEYE_NB2_FINAL and the predictor of interest (i.e., YEAR).
## A 95% "uncertainty interval" (ui) is also calculated. This can take several seconds to run.

set.seed(2025)

model <- m_WALLEYE_NB2_FINAL
predictor <- "YEAR"

viz_fun <- function(model, predictor) {
  viz <- getViz(model, nsim = 100)
  plot <- check1D(viz, predictor) + l_gridCheck1D(n = 100)
  diag_plot <- plot$ggObj
  est <- diag_plot$layers[[1]]$data
  ll <- diag_plot$layers[[3]]$data$ll
  ul <- diag_plot$layers[[3]]$data$ul
  diag <- cbind(est, ll, ul)
  diagnostic <- mutate(diag,
                       ll_diff = y - ll,
                       ul_diff = ul - y,
                       test = ll_diff * ul_diff)
  n <- length(diagnostic$test)
  i_n <- sum(diagnostic$test >= 0)
  mgcViz_perc <- i_n / n * 100
  mgcViz_perc
}

summary_mgcViz <- replicate(100, viz_fun(model, predictor))

mgcViz_score <- mean(summary_mgcViz)
lower_ui <- (quantile(summary_mgcViz, probs = 0.025))[[1]]
upper_ui <- (quantile(summary_mgcViz, probs = 0.975))[[1]]

cbind(mgcViz_score, lower_ui, upper_ui)


######################################## MODEL SELECTION ####################################

## Using the compareML() function of "itsadug" indicates that the final NB2 GAMM offers
## an equivalent fit to that of the initial fully-parameterized counterpart despite being much
## less complex, as captured by the Estimated degrees of freedom (Edf).

compareML(m_WALLEYE_NB2_FINAL, m_WALLEYE_NB2_FULL)


## Comparing these same two models under an information-theoretic approach indicates that the
## final NB2 GAMM is much more parsimonious than its fully-parameterized counterpart using the
## model.sel() function of "MuMIn" according to BICc

model.sel(m_WALLEYE_NB2_FINAL, m_WALLEYE_NB2_FULL, rank = BICc)


############################ "IN-SAMPLE" PREDICTIVE PERFORMANCE #############################

## First, refit the final NB2 GAMM with REML instead of ML

m_WALLEYE_NB2_FINAL_REML <- gam(N ~ s(YEAR) + D1AUG + DEPTH + s(TURBID)
                                + s(AREA, bs = "re"),
                                family = nb,
                                method = "REML",
                                data = WALLEYE)

summary(m_WALLEYE_NB2_FINAL_REML)


## Estimate the deviance explained (D2) and its adjusted version (D2_adj) for
## the final model relying on REML estimation

model <- m_WALLEYE_NB2_FINAL_REML

D2 <- 100 * (1 - model$deviance / model$null.deviance)
logLik <- logLik(model)
K <- attributes(logLik)$df
n <- summary(model)$n
D2_adj <- 100 - ((n - 1) / (n - K) * (100 - D2))
round(cbind(D2, D2_adj), 1)


#################################### MODEL PREDICTIONS #######################################

## Predictions with "mgcv" for the final NB2 GAMM refitted with REML (Fig. 2a)

nd_WALLEYE <- data.frame(YEAR = seq(2001, 2021, by = 0.1),
                         D1AUG = mean(WALLEYE$D1AUG),
                         DEPTH = mean(WALLEYE$DEPTH),
                         TURBID = mean(WALLEYE$TURBID),
                         AREA = "NA")

model <- m_WALLEYE_NB2_FINAL_REML

fitted <- predict(model,
                  nd_WALLEYE,
                  type = "link",
                  exclude = "s(AREA)",
                  se.fit = TRUE)

estimate <- exp(fitted$fit)
lower_ci <- exp(fitted$fit - 1.96 * fitted$se.fit)
upper_ci <- exp(fitted$fit + 1.96 * fitted$se.fit)

cbind(YEAR = nd_WALLEYE$YEAR, estimate, lower_ci, upper_ci)

