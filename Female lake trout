## Required packages:

library(FSA)
library(hnp)
library(itsadug)
library(mgcv)
library(mgcViz)
library(MuMIn)
library(performance)
library(tidyverse)


## Function for the calculation of the sample-adjusted BIC (BICc)

BICc <- function (obj) {
  bic <- BIC(obj)
  n <- obj$df.null + 1
  p <- n - obj$df.residual
  bicc <- bic + (log(n) * (p + 1) * p)/(n - p - 1)
  return(bicc)
}


################################################################################
######## EXAMPLE 1: LENGTH-AT-AGE RELATIONSHIP IN FEMALE LAKE TROUT ############
################################################################################

## Load the TROUT dataset as an example with a continuous response variable 

url <- "https://raw.githubusercontent.com/julienmainguy/GAM-adequacy/refs/heads/main/TROUT.txt"
TROUT <- read.delim(url)

## GENERALIZED ADDITIVE MIXED-EFFECTS MODELING (GAMM) ##########################

## Fitting the Gaussian distribution, as done for the nonlinear mixed-effects von 
## Bertalanffy growth model, to a GAMM with the default parametrization for s(),
## such that it is identified with *_TP* from using thin-plate regression splines.
## Note that s(AGE, bs = "tp", k = 10) is equivalent to just using s(AGE), whereas
## family = gaussian(link = "identity") is the same as using family = gaussian.

TROUT$LAKE <- as.factor(TROUT$LAKE)

m_TROUT_GAUSSIAN_TP <- gam(TL ~ s(AGE, bs = "tp", k = 10) + s(LAKE, bs = "re"),
                           family = gaussian(link = "identity"),
                           method = "ML",
                           data = TROUT)

summary(m_TROUT_GAUSSIAN_TP)

## Fitting an alternative Gaussian GAMM with an adaptive smooth *_AD* again using
## the ML method in "mgcv". The default k = 10 is increased to 20 to further penalize
## against wiggliness. Using k = 20 is possible given that the TROUT dataset contains
## 37 distinct AGE values.

m_TROUT_GAUSSIAN_AD <- gam(TL ~ s(AGE, bs = "ad", k = 20) + s(LAKE, bs = "re"),
                           family = gaussian(link = "identity"),
                           method = "ML",
                           data = TROUT)

summary(m_TROUT_GAUSSIAN_AD)

## Fitting the Gamma distribution with a log link (Forbes et al. 2010) instead as
## just done above with the Gaussian distribution. Note that using family = Gamma
## only will use an inverse link function as a default setting, such that explicitly
## indicating family = Gamma(link = "log") is required for fitting a log link 
## function instead, which is intended here. An adaptive smooth *_AD* is used again
## here given the bioligically unrealistic wiggling at older ages that thin-plate
## regression splines generate due to the sparsely distributed observations.

m_TROUT_GAMMA_AD <- gam(TL ~ s(AGE, bs = "ad", k = 20) + s(LAKE, bs = "re"),
                        family = Gamma(link = "log"),
                        method = "ML",
                        data = TROUT)

summary(m_TROUT_GAMMA_AD)


## MODEL ADEQUACY --------------------------------------------------------------

## Diagnostic plots with the gam.check() function of "mgcv" for the Gaussian
## GAMM with an adaptive smooth. Similar diagnostic plots are produced for the
## gamma GAMM, with homoscedasticity for instance only being applicable to the
## Gaussian case (which is not apparently respected from a visual inspection).

gam.check(m_TROUT_GAUSSIAN_AD)


## Diagnostic half-normal plot of the deviance residuals using the hnp() 
## function of "hnp" and a newly-made available sfun() helper function for the
## Gaussian distribution. The right-hand part following "resp ~" of the ffun helper
## function should match that of the Gaussian GAMM built in "mgcv" that is being
## assessed for adequacy. This step can take several seconds to run.

model <- m_TROUT_GAUSSIAN_AD 
family <- gaussian(link = "identity")
method <- "ML"  
data <- TROUT

dfun <- function(obj) resid(obj, type = "deviance")

sfun <- function(n, obj) {
  y <- rnorm(nrow(data),
             mean = predict(model, type = "response"),
             sd = sqrt(model$sig2))
  return(y)
}

ffun <- function(resp) {
  gam(resp ~ s(AGE, bs = "ad", k = 20) + s(LAKE, bs = "re"),
      family = family,
      method = method,
      data = data)
}

hnp(model,
    newclass = TRUE, 
    diagfun = dfun, 
    simfun = sfun, 
    fitfun = ffun, 
    how.many.out = TRUE, 
    plot = TRUE, 
    paint = TRUE,
    ylab = "Deviance residuals")

## Performing 10 "hnp" iterations to obtain a mode and a mean percentage of 
## residuals outside the simulated envelope for the same Gaussian GAMM with an
## adaptive smooth. A seed is only used for result reproducibility.

set.seed(2025)

n <- 10

hnp_obj <- list()
for (i in 1:n) {
  hnp_obj[[i]] <- hnp(model, 
                      newclass = TRUE,
                      diagfun = dfun,
                      simfun = sfun,
                      fitfun = ffun,
                      how.many.out = TRUE,
                      plot.sim = FALSE)
}

hnp_summary <- sapply(hnp_obj, function(x) x$out / x$total * 100) 

return_max <- function(numvec) {
  dens <- density(numvec)
  return(dens$x[which.max(dens$y)][1])
}

## Mode percentage of residuals outside the simulated envelope

round(return_max(hnp_summary), 2)

## Mean percentage of residuals outside the simulated envelope with other
## descriptive statistics using the Summarize() function of "FSA".

Summarize(hnp_summary)

## Diagnostic half-normal plot of the deviance residuals using the hnp() 
## function of "hnp" and a newly-made available sfun() helper function for the
## gamma distribution with a log link that uses an adaptive *_AD* spline.

model <- m_TROUT_GAMMA_AD
family = Gamma(link = "log")
method = "ML"
data = TROUT

dfun <- function(obj) resid(obj, type = "deviance")

sfun <- function(n, obj) simulate(obj)[,1]

ffun <- function(resp) gam(resp ~ s(AGE, bs = "ad", k = 20) + s(LAKE, bs = "re"),
                           family = family,
                           method = method,
                           data = data)

hnp(model,
    newclass = TRUE,
    diagfun = dfun,
    simfun = sfun,
    fitfun = ffun,
    how.many.out = TRUE,
    plot = TRUE,
    paint = TRUE,
    ylab = "Deviance residuals")

## Perform 10 consecutive "hnp" runs to obtain a mode and a mean percentage of 
## the points outside the simulated envelope from the same gamma GAMM being 
## assessed for adequacy. The set.seed() function is solely used for reproducibility.
## The modal percentage is first calculated and then the mean with other descriptive
## statistics. This step can take several minutes to run

set.seed(2025)

hfun <- list()
for(i in 1:10) {
  hfun[[i]] <- hnp(model,
                   newclass = TRUE,
                   diagfun = dfun,
                   simfun = sfun,
                   fitfun = ffun,
                   how.many.out = TRUE,
                   plot.sim = FALSE)
}

hnp_summary <- sapply(hfun, function(x) x$out / x$total * 100) 

## Modal percentage as estimated from a density curve

return_max <- function(numvec) {
  dens <- density(numvec)
  return(dens$x[which.max(dens$y)][1])
}

round(return_max(hnp_summary), 2)

## Descriptive statistics, including the mean

Summarize(hnp_summary)


## Diagnostic plots using the getviz(), check1D(), and l_gridCheck1D() functions 
## of "mgcViz" with 100 model-derived simulations (nsim) for an "mgcv" object, here
## for the gamma GAMM with an adaptive smooth. Only the model and predictor must
## be defined for the code to work.

model <- m_TROUT_GAMMA_AD
predictor <- "AGE"

set.seed(2025)

viz <- getViz(model, nsim = 100)
plot <- check1D(viz, predictor) + l_gridCheck1D(n = 100)
diag_plot <- plot$ggObj
est <- diag_plot$layers[[1]]$data
ll <- diag_plot$layers[[3]]$data$ll
ul <- diag_plot$layers[[3]]$data$ul
diag <- cbind(est, ll, ul)
diagnostic <- mutate(diag,
                     ll_diff = y - ll,
                     ul_diff = ul - y,
                     test = ll_diff * ul_diff)
n <- length(diagnostic$test)
i_n <- sum(diagnostic$test >= 0)
mgcViz_perc <- i_n / n * 100

## Visualize the mgcViz diagnostic plot

diag_plot

## Obtain the percentage of the binned residual means found within the
## simulated default 80% confidence limits shown on the mgcViz diagnostic plot

mgcViz_perc

## Calculate the mgcViz score (mean) for a given model based on 100 iterations,
## each relying on 100 model-based simulations. An associated 95% "uncertainty 
## interval" (ui) is also calculated. Here again for the gamma GAMM with an
## adaptive smooth. This can take several seconds to run.

model <- m_TROUT_GAMMA_AD
predictor <- "AGE"

set.seed(2025)

viz_fun <- function(model, predictor) {
  viz <- getViz(model, nsim = 100)
  plot <- check1D(viz, predictor) + l_gridCheck1D(n = 100)
  diag_plot <- plot$ggObj
    est <- diag_plot$layers[[1]]$data
    ll <- diag_plot$layers[[3]]$data$ll
    ul <- diag_plot$layers[[3]]$data$ul
    diag <- cbind(est, ll, ul)
    diagnostic <- mutate(diag,
                       ll_diff = y - ll,
                       ul_diff = ul - y,
                       test = ll_diff * ul_diff)
  n <- length(diagnostic$test)
  i_n <- sum(diagnostic$test >= 0)
  mgcViz_perc <- i_n / n * 100
  mgcViz_perc
}

summary_mgcViz <- replicate(100, viz_fun(model, predictor))

mgcViz_score <- mean(summary_mgcViz)
lower_ui <- (quantile(summary_mgcViz, probs = 0.025))[[1]]
upper_ui <- (quantile(summary_mgcViz, probs = 0.975))[[1]]

cbind(mgcViz_score, lower_ui, upper_ui)


## MODEL SELECTION #############################################################

## Compare Maximum Likelihood scores while accounting for model complexity (Edf) 
## for the two candidates GAMMs using the compareML() function of "itsadug". The
## GAMMs being compared must share the same random structure.

compareML(m_TROUT_GAUSSIAN_AD, m_TROUT_GAMMA_AD)

## Compare the two candidate gamma GAMMs fitted in "mgcv" based on AICc under
## an information-theoretic approach using the model.sel() function of "MuMIn".

model.sel(m_TROUT_GAUSSIAN_AD, m_TROUT_GAMMA_AD, rank = BICc)


## Refit the gamma GAMM using an adaptive smooth with REML estimation in "mgcv"

m_TROUT_GAMMA_AD_REML <- gam(TL ~ s(AGE, bs = "ad", k = 20) + s(LAKE, bs = "re"),
                             family = Gamma(link = "log"),
                             method = "REML",
                             data = TROUT)

summary(m_TROUT_GAMMA_AD_REML)


## "IN-SAMPLE" PREDICTIVE PERFORMANCE ##########################################

## Estimate the deviance explained (D2) and its adjusted version (D2_adj) for
## the preferred gamma GAMM using an adaptive smooth relying on REML estimation.
## Note here that K (i.e., number of parameters) corresponds to the sum of df 
## and edf as estimated by "mgcv" from using the logLik() function.

model <- m_TROUT_GAMMA_AD_REML

D2 <- 100 * (1 - model$deviance / model$null.deviance)
logLik <- logLik(model)
K <- attributes(logLik)$df
n <- summary(model)$n
D2_adj <- 100 - ((n - 1) / (n - K) * (100 - D2))
round(cbind(D2, D2_adj), 1)


## MODEL PREDICTIONS ##########################################################

## Predictions from the best-retained gamma GAMM with REML estimation (Fig. 1c).
## Note that the predictions are at the log link scale, such that exponentiation
## of the predictions is required for their visualization at the response scale.

model <- m_TROUT_GAMMA_AD_REML

nd_TROUT <- data.frame(AGE = seq(1, 50, by = 0.1),
                       LAKE = "BRULE")

fitted <- predict(model,
                  nd_TROUT,
                  type = "link",
                  exclude = "s(LAKE)",
                  se.fit = TRUE)

estimate <- exp(fitted$fit)
lower_ci <- exp(fitted$fit - 1.96 * fitted$se.fit)
upper_ci <- exp(fitted$fit + 1.96 * fitted$se.fit)

age <- nd_TROUT$AGE
cbind(age, estimate, lower_ci, upper_ci)

